import math  # Fixed typo
from math import pi
import stlwrite
import csg

def frange(x, maximum, step):
    while x < maximum:
        yield x
        x += step

def get_ellipsoid(A,B,C,x0,y0,z0):

    """""
    Parameters:
        A, B, C: semi-axis lengths (A=x-axis, B=y-axis, C=z-axis)
        x0, y0, z0: center coordinates
        x(theta, phi) = x0 + Acose(theta)cos(phi)
        y(theta, phi) = y0 + Bsin(theta)cos(phi) <-- cos(phi) bc is lattitude so on same line as x
        z(theta, phi) = z0 + Csin(phi) <-- C represents the flattness/roundness of the shape, A=B=C is a perfect
        sphere

    Process:
        -Create triangle faces, each face being [p1, p2, p3]
        2 Cases:
            1) We create a rectangle where the top line is a different level of phi than the bottom with 4 pts (p1,p2,p3,p4)
            This will create 2 triangles [p1, p2, p3] & [p1, p3, p4]
            2) When we at the north or south pole, all triangles converge into one pt, so @ phi = pi/2 or -pi/2
                -this is basically 2 casses for bottom and top end
    ^this is for my ref when im coding dw about it

    """

    faces = []
    theta_step = math.pi / 8
    phi_step = math.pi / 8
    
    def ellipsoid_point(theta, phi):
        x = x0 + A * math.cos(theta) * math.cos(phi)
        y = y0 + B * math.sin(theta) * math.cos(phi)
        z = z0 + C * math.sin(phi)
        return (x, y, z)
    
    # phi from -π/2 to +π/2 <-- top to bottom of sphere/oval thingy
    phi_start = -math.pi / 2
    phi_end = math.pi / 2
    
    phi = phi_start
    while (phi < phi_end - phi_step/2):  # /2 is so it don't stop too early, buffer
        phi_next = phi + phi_step
        
        # Case 2.1 (bottom) - phi = -π/2

        if abs(phi - phi_start) < 1e-5: #the code tweaks when I say phi_next == phi_start, have to acc for small discrapency
            # cos(phi) = 0
            south_pole = ellipsoid_point(0, phi)

            #create triangles from south pole to first latitude ring - as in first circle from bottom
            theta = 0
            
            while (theta < 2 * math.pi - theta_step/2):
                theta_next = theta + theta_step
                
                p1 = ellipsoid_point(theta, phi_next)
                p2 = ellipsoid_point(theta_next, phi_next)
                
                # Triangle from pt_south_pole -> p1 -> p2 
                faces.append([south_pole, p2, p1])  

                theta += theta_step
        
        # Case 2.2 (top) - phi = π/2
        elif abs(phi_next - phi_end) < 1e-5: #for code tweaking again bruhhhhhhhhhhhhhh
            # at north pole, cos(phi) = 0 again
            north_pole = ellipsoid_point(0, phi_next)
            
            #create triangles from last latitude ring to north pole
            theta = 0
            while theta < 2 * math.pi - theta_step/2:
                theta_next = theta + theta_step
                
                p1 = ellipsoid_point(theta, phi)
                p2 = ellipsoid_point(theta_next, phi)
                
                faces.append([p1, p2, north_pole])
                
                theta += theta_step
        
        # Case 1 
        else:
            theta = 0
            while theta < 2 * math.pi - theta_step/2:
                theta_next = theta + theta_step
                
                # Four corners of the rect thingie
                p1 = ellipsoid_point(theta, phi)           # bottomLeft
                p2 = ellipsoid_point(theta_next, phi)      # bottomRight
                p3 = ellipsoid_point(theta_next, phi_next) # topRight
                p4 = ellipsoid_point(theta, phi_next)      # topLeft
                
                # triag1 = p1 -> p2 -> p3
                faces.append([p1, p2, p3])
                # triag2 =  p1 -> p3 -> p4
                faces.append([p1, p3, p4])
                
                theta += theta_step
        
        phi += phi_step
    
    return faces


def get_duck_features():
    """Return a list of body parts. Each body part is a list of faces
        (quads or triangles) generated by get_ellipsoid().  So the result is
        a list of lists of faces.
    """
    
    body_parts = []
    
    # beak 
    body_parts.append(get_ellipsoid(0.7, 0.7, 0.2, 0.5, -0.2*pi, 0.5*pi))

    # head 
    body_parts.append(get_ellipsoid(1.3, 1.3, 1.1, 0.5, 0.5, 0.5*pi))

    # left eye 
    body_parts.append(get_ellipsoid(0.25, 0.25, 0.25, 1.45, 0.1, 0.6*pi))

    # right eye 
    body_parts.append(get_ellipsoid(0.25, 0.25, 0.25, -0.45, 0.1, 0.6*pi))

    # neck 
    body_parts.append(get_ellipsoid(0.75, 0.75, 1, 0.5, 0.5, 0.5))

    # body 
    body_parts.append(get_ellipsoid(2.8, 2.5, 1.57, 0.5, 0.75*pi, 0))

    # left wing 
    body_parts.append(get_ellipsoid(0.3, 1.6, 0.8, 3, 0.8*pi, 0))

    # right wing 
    body_parts.append(get_ellipsoid(0.3, 1.6, 0.8, -2, 0.8*pi, 0))

    # tail 
    body_parts.append(get_ellipsoid(0.6, 1.2, 0.2, 0.5, 1.4*pi, 0.1*pi))

    return body_parts

    

def write_simple_duck():
    parts = get_duck_features()
    # Put all the faces together in one big list.
    faces = []
    for part in parts:
        faces.extend(part)
    # Write the list as an STL file
    filename = "simple_duck.stl"
    with open(filename, 'wb') as fp:
        writer = stlwrite.ASCII_STL_Writer(fp)
        writer.add_faces(faces)
        writer.close()
    print("Wrote " + filename)
    
def write_good_duck():
    filename = "duck_union.stl"
    # Do a mesh union of all the body parts
    body_parts = get_duck_features()
    good_mesh = csg.union_all(body_parts)
    good_mesh.saveSTL(filename, binary=False)

if __name__ == "__main__":
    # write_simple_duck()    
    write_good_duck()      